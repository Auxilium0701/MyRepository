class Cat(object):
    """ Виртуальная кошка """
    total = 0 # сколько кошек изначально
    # Декоратор в Python – это функция, которая принимает другую функцию 
    # в качестве аргумента. 

    # Декоратор начинается с символа @, за которым следует название функции, 
    # которую мы собираемся «декорировать»

    # Декоратор @staticmethod — это просто функция внутри класса. 
    # Вы можете вызывать их обоих как с инициализацией класса 
    # так и без создания экземпляра класса. 

    # Обычно это применяется в тех случаях, когда у вас есть функция, 
    # которая, по вашему убеждению, имеет связь с классом. 

    # Проще говоря, @staticmethod — это вроде обычной функции, 
    # определенной внутри класса, которая не имеет доступа к экземпляру, 
    # поэтому ее можно вызывать без создания экземпляра класса.

    @staticmethod
    # функция для счета количества кошек
    def count():
        print("Всего кошек: ", Cat.total)
    
    #  метод __init__ принимает аргументы для нашего класса
    def __init__(self):
        print("Родилась новая кошка!")
        self.name = input("Как мы её назовём? ") # даем имя кошки при рождении
        Cat.total += 1 # счетчик кошек (при рождении +1)
        self.__w = 300 # начальный вес кошки __w это закрытый атрибут
        self.hunger = 1 # начальный голод кошки
        
    # метод __str__ отвечает за строкое представление объекта
    def __str__(self):
        res = "Объект класса Cat\n name: " + self.name + "\nBec: " + str(self.__w) 
        # метод str() возвращает строку
        return res # Оператор return используется в функциях 
        #для возвращения данных после выполнения работы самой функции.

    # @property в Python – один из встроенных декораторов. 

    # Основная цель любого декоратора – изменить методы или атрибуты 
    # вашего класса таким образом, 
    # чтобы пользователю вашего класса не нужно было 
    # вносить какие-либо изменения в свой код.

    @property
    # функция веса кошки. Берет из закрытого атрибута
    def weight(self):
        return self.__w
    
    # функция рождения кошки и его первого мяу..
    def talk(self):
        print(self.name, ": Мяу")
    
    # функция кормления кошки. 
    # При каждом кормлении вес кошки увеличивается на 30 граммов.
    def eat(self):
        if self.hunger == 5:
            print("Кошка не голодная")
        else:
            self.hunger += 1
            self.__w += 30
            print("Мур!")

    # функиция для игры с кошкой. 
    # При каждой игре с кошкой она теряет 5 грамм веса.
    def play(self):
        self.talk()
        self.__w -= 5
        if self.hunger > 0:
            self.hunger -= 1
        else:
            self.hunger = 1

# Основная функция для управления всей программой из меню.    
def main():

    bagira = Cat()
    choice = None
    while choice != "0":
        print \
        ("""
        Что будем делать?
            
        0 - Выйти
        1 - Поговорить с кошкой
        2 - Покормить
        3 - Поиграть
        4 - Взвесить
        """)
            
        choice = input(">>: ")
        print()

        # exit
        if choice == "0":
            print("Пока.")
            
        # послушать
        elif choice == "1":
            bagira.talk()
                
        # покормить
        elif choice == "2":
            bagira.eat()
                
        # поиграть
        elif choice == "3":
            bagira.play()
        elif choice == "4":
            print("Вес: ", bagira.weight, " гр. ")
            
        # неправильный ввод
        else:
            print("\nНеправильный ввод!")  
main() # вызов функции            
input()